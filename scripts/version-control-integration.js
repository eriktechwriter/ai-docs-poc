#!/usr/bin/env node

/**
 * Version Control Integration - MVP
 * 
 * Simple Git integration for tracking AI-assisted changes.
 * Follows MVP approach: leverages existing Git, simple tracking.
 */

const fs = require('fs');
const path = require('path');
const chalk = require('chalk');
const { execSync } = require('child_process');

class VersionControlIntegration {
  constructor() {
    this.projectRoot = path.join(__dirname, '..');
  }

  // Create AI-specific commit with metadata
  createAICommit(contentPath, metadata = {}) {
    try {
      const featureName = path.basename(contentPath);
      const commitMessage = this.generateAICommitMessage(featureName, metadata);
      
      // Add AI metadata to commit
      const aiMetadata = {
        type: 'ai-generated',
        feature: featureName,
        generatedAt: new Date().toISOString(),
        qualityScore: metadata.qualityScore,
        templates: metadata.templates || [],
        reviewer: metadata.reviewer
      };
      
      // Save metadata file
      const metadataPath = path.join(contentPath, '.ai-commit-metadata.json');
      fs.writeFileSync(metadataPath, JSON.stringify(aiMetadata, null, 2));
      
      // Git operations
      execSync(`git add "${contentPath}"`, { cwd: this.projectRoot });
      execSync(`git commit -m "${commitMessage}"`, { cwd: this.projectRoot });
      
      console.log(chalk.green('✅ AI commit created'));
      console.log(chalk.gray(`Message: ${commitMessage}`));
      
      return true;
    } catch (error) {
      console.log(chalk.yellow('⚠️  Could not create Git commit:'), error.message);
      return false;
    }
  }

  generateAICommitMessage(featureName, metadata) {
    const qualityText = metadata.qualityScore ? 
      ` (Quality: ${Math.round(metadata.qualityScore * 100)}%)` : '';
    
    const reviewText = metadata.reviewer ? ` - Reviewed by ${metadata.reviewer}` : '';
    
    return `AI: Generate ${featureName} documentation${qualityText}${reviewText}

- Generated using AI content system
- Templates: ${(metadata.templates || []).join(', ')}
- Quality checks: Passed
- Ready for review`;
  }

  // Track AI changes in a simple log
  logAIChange(action, details) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      action: action,
      details: details,
      user: process.env.USER || 'unknown'
    };
    
    const logPath = path.join(this.projectRoot, '.ai-changes.log');
    const logLine = JSON.stringify(logEntry) + '\\n';
    
    fs.appendFileSync(logPath, logLine);
    
    console.log(chalk.blue(`📝 Logged AI change: ${action}`));
  }

  // Generate change summary for reviews
  generateChangeSummary(contentPath) {
    try {
      const featureName = path.basename(contentPath);
      
      // Get Git diff if available
      let diffSummary = 'No previous version for comparison';
      try {
        const diff = execSync(`git diff --name-only HEAD~1 "${contentPath}"`, { 
          cwd: this.projectRoot,
          encoding: 'utf8'
        });
        
        if (diff.trim()) {
          diffSummary = `Modified files:\\n${diff.trim().split('\\n').map(f => `- ${f}`).join('\\n')}`;
        } else {
          diffSummary = 'New content (no previous version)';
        }
      } catch (error) {
        // No previous version or Git not available
      }
      
      const summary = `# Change Summary: ${featureName}

**Generated:** ${new Date().toLocaleDateString()}
**Type:** AI-generated content

## Changes Made
${diffSummary}

## AI System Information
- Content generated using template system
- Quality analysis performed
- Enterprise standards applied
- Ready for human review

## Next Steps
1. Review generated content
2. Provide feedback if changes needed
3. Approve for publication
4. Integrate with documentation site

---
*Generated by AI Version Control Integration*`;

      const summaryPath = path.join(contentPath, 'CHANGE_SUMMARY.md');
      fs.writeFileSync(summaryPath, summary);
      
      console.log(chalk.green(`✅ Change summary created: ${summaryPath}`));
      return summaryPath;
      
    } catch (error) {
      console.log(chalk.yellow('⚠️  Could not generate change summary:'), error.message);
      return null;
    }
  }

  // Simple branch management for AI content
  createAIBranch(featureName) {
    try {
      const branchName = `ai-content/${featureName}-${Date.now()}`;
      
      execSync(`git checkout -b ${branchName}`, { cwd: this.projectRoot });
      
      console.log(chalk.green(`✅ Created AI branch: ${branchName}`));
      return branchName;
      
    } catch (error) {
      console.log(chalk.yellow('⚠️  Could not create branch:'), error.message);
      return null;
    }
  }

  // Get AI change history
  getAIChangeHistory() {
    const logPath = path.join(this.projectRoot, '.ai-changes.log');
    
    if (!fs.existsSync(logPath)) {
      return [];
    }
    
    const logContent = fs.readFileSync(logPath, 'utf8');
    const entries = logContent.trim().split('\\n')
      .filter(line => line.length > 0)
      .map(line => {
        try {
          return JSON.parse(line);
        } catch (error) {
          return null;
        }
      })
      .filter(entry => entry !== null);
    
    return entries.reverse(); // Most recent first
  }

  // Display change history
  displayChangeHistory(limit = 10) {
    const history = this.getAIChangeHistory();
    
    if (history.length === 0) {
      console.log(chalk.yellow('No AI changes recorded'));
      return;
    }
    
    console.log(chalk.cyan(`\\n📋 Recent AI Changes (${Math.min(limit, history.length)} of ${history.length}):`));
    
    for (const entry of history.slice(0, limit)) {
      const date = new Date(entry.timestamp).toLocaleDateString();
      const time = new Date(entry.timestamp).toLocaleTimeString();
      
      console.log(chalk.white(`\\n${date} ${time} - ${entry.action}`));
      
      if (entry.details.feature) {
        console.log(chalk.gray(`   Feature: ${entry.details.feature}`));
      }
      
      if (entry.details.qualityScore) {
        console.log(chalk.gray(`   Quality: ${Math.round(entry.details.qualityScore * 100)}%`));
      }
      
      console.log(chalk.gray(`   User: ${entry.user}`));
    }
  }
}

// CLI execution
async function main() {
  const vcs = new VersionControlIntegration();
  
  const args = process.argv.slice(2);
  
  if (args.includes('--history')) {
    const limit = parseInt(args[args.indexOf('--history') + 1]) || 10;
    vcs.displayChangeHistory(limit);
  } else {
    console.log(chalk.blue('🔄 Version Control Integration'));
    console.log(chalk.gray('Track AI-assisted documentation changes\\n'));
    console.log('Usage:');
    console.log('  --history [limit]   Show AI change history');
  }
}

module.exports = VersionControlIntegration;

if (require.main === module) {
  main().catch(error => {
    console.error(chalk.red('Error:'), error.message);
    process.exit(1);
  });
}