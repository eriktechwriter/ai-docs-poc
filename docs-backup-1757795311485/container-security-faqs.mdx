---
slug: trend-vision-one-container-security-faqs
title: Container Security FAQs
---
# Container Security FAQs

:- How do I manually create a Kubernetes network policy for continuous compliance?

- How do I perform Helm chart operations related to Container Security?

- How do I collect logs for troubleshooting purposes?

- Why am I getting a '401 Unauthorized' message on API calls?

- Does Container Security require inbound network access to my Kubernetes cluster?

- Are regular expressions supported when creating policies?

- Does each Kubernetes cluster need its own admission controller?

- Will the validation of admission control webhooks cause Container Security to change a container's configuration?

- During the validating phase, when you run kubectl apply -f \<...\>, does the admission controller query Container Security? If so, is a local cache being used for each query?

- What is the telemetry in Container Security used for? What kind of data is admission control sending?

- When should you increase the replica count for the admission controller?

- How do you add pods with multiple containers to exceptions?

- Why is my pod not being isolated from network access?

- Why are vulnerabilities not showing up in the vulnerability view?

- Can I have multiple scan tools installed in my cluster?

- When should I increase the maximum concurrency for the vulnerability scanner pods?

- How do I collect ECS Scout service logs?

- How do I pull images from a private registry?

- Why does the sidecar container exit with code 137 in AWS Fargate?

- How do I resolve a Trend Vision One Container Security Argo CD application stuck in a Deleting state during uninstall?

- How do I verify the authenticity of Trend Micro container images with Cosign public keys?

## How do I manually create a Kubernetes network policy for continuous compliance? {#how-do-i-manually-create-a-kubernetes-network-policy-for-continuous-compliance}

By default, Container Security continuous compliance creates a Kubernetes network policy on your behalf. If you want to create the policy manually, follow the steps below:

### Procedure {#procedure}

1.  Change the value of `cloudOne.oversight.enableNetworkPolicyCreation` to `false`.

    ```bash
      visionOne:
        oversight:
          enableNetworkPolicyCreation: false
    ```

2.  Create a network policy with `matchLabels` set to `trendmicro-cloud-one: isolate` in your desired namespaces.

    ```bash
      apiVersion: networking.k8s.io/v1
      kind: NetworkPolicy
      metadata:
        labels:
          app.kubernetes.io/instance: trendmicro
        name: trendmicro-oversight-isolate-policy
      spec:
        podSelector:
          matchLabels:
            trendmicro-cloud-one: isolate
        policyTypes:
        - Ingress
        - Egress
    ```

    :::warning[Important]

    The network policy with matchLabels `trendmicro-cloud-one: isolate` must exist in each application namespaces in order to perform proper isolation mitigation.
    :::

## How do I perform Helm chart operations related to Container Security? {#how-do-i-perform-helm-chart-operations-related-to-container-security}

Reference the following table to locate the available tasks you can perform using Helm commands.

<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr>
<th><p>Task</p></th>
<th><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Upgrade your Container Security deployment</p></td>
<td><p>To upgrade an existing installation in the default Kubernetes namespace to the latest version:</p>
<pre class="codeblock"><code>  helm upgrade \
    --values overrides.yaml \
    --namespace ${namespace} \
    trendmicro \
    https://github.com/trendmicro/visionone-container-security-helm/archive/main.tar.gz</code></pre>
<p>The above script overrides or resets the values in the overrides.yaml file. If you want to use the values that you had previously, use the <code>-reuse-values</code> parameter during the Helm upgrade:</p>
<pre class="codeblock"><code>  helm upgrade \
    --namespace ${namespace} \
    --reuse-values \
    trendmicro \
    https://github.com/trendmicro/visionone-container-security-helm/archive/main.tar.gz </code></pre></td>
</tr>
<tr>
<td><p>Enabling or disabling a specific component</p></td>
<td><p>Specific components of the Container Security Helm chart can be enabled or disabled individually using an overrides file. For example, you can choose to enable the runtime security component by including the below in your <code>overrides.yaml</code> file:</p>
<pre class="codeblock"><code>  visionOne:
    runtimeSecurity:
      enabled: true</code></pre></td>
</tr>
<tr>
<td><p>Enable runtime security on AWS Bottlerocket</p></td>
<td><p>By default, AWS EKS Auto Mode uses nodes with the Bottlerocket operating system. Before deploying Container Security to an Auto Mode cluster, run Runtime Security on AWS Bottlerocket nodes by adding these configurations in your <code>overrides.yaml</code> file:</p>
<pre class="codeblock"><code>securityContext:
  scout:
    scout:
      allowPrivilegeEscalation: true
      privileged: true</code></pre></td>
</tr>
</tbody>
</table>

## How do I collect logs for troubleshooting purposes? {#how-do-i-collect-logs-for-troubleshooting-purposes}

When troubleshooting an issue, you have several logs that you can use.

### Access logs {#access-logs}

Most issues can be investigated using the application logs. The logs can be accessed using `kubectl`.You can access the logs for the

- Admission controller using the following command:

  ```bash
  kubectl logs deployment/trendmicro-admission-controller --namespace ${namespace}
  ```

- Runtime security component using the following command, where container can be one of `scout`, or `falco`:

  ```bash
   kubectl logs daemonset/trendmicro-scout --namespace ${namespace} -c
       ${container}
  ```

- Oversight controller (Continuous Compliance policy enforcement) using the following command:

  ```bash
   kubectl logs deployment/trendmicro-oversight-controller [controller-manager |
       rbac-proxy] --namespace ${namespace}
  ```

- Usage controller using the following command:

  ```bash
   kubectl logs deployment/trendmicro-usage-controller [controller-manager | rbac-proxy]
       --namespace ${namespace}
  ```

### Collect support logs {#collect-support-logs}

When opening a support case, reproduce the issue with debug logging enabled and include the debug log package. The log package helps your support provider to debug issues, particularly those related to in-cluster components or communication. A log collection script is available for you to use from [Trend Micro](https://raw.githubusercontent.com/trendmicro/cloudone-container-security-helm/refs/heads/master/scripts/collect-logs.sh).

Use the following steps to enable debug logging:

1.  Set the `logConfig.logLevel` to `debug` in the `overrides.yaml` file and upgrade the helm chart.

    ```bash
    logConfig:
      logLevel: debug
    ```

2.  Reproduce the issue and gather logs using the following command:

    ```bash
    ./collect-logs.sh
    ```

The following environment variables are supported for log collection:

<table>
<thead>
<tr>
<th>Environment variable</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>RELEASE</td>
<td>Helm release name</td>
<td><code>trendmicro</code></td>
</tr>
<tr>
<td>NAMESPACE</td>
<td>The namespace that the Helm chart is deployed in</td>
<td>Current namespace declared in <code>kubeconfig</code>. If no namespace setting exists in <code>kubeconfig</code>, then <code>trendmicro-system</code> will be used.</td>
</tr>
</tbody>
</table>

## Why am I getting a '401 Unauthorized' message on API calls? {#why-am-i-getting-a-401-unauthorized-message-on-api-calls}

This is usually because you haven't created an API key to authenticate your requests with Container Security. For information on creating and using a Trend Vision One API key, see [Obtain an API key](obtaining-api-key.mdx).

*Deprecated*: For information on creating and using a legacy API key, see the Workload Security [API key help](https://docs.trendmicro.com/en-us/documentation/article/trend-micro-cloud-one-workload-security-api-keys).

## Does Container Security require inbound network access to my Kubernetes cluster? {#does-container-security-require-inbound-network-access-to-my-kubernetes-cluster}

Container Security currently does not require any inbound network access and does not require any extra IP addresses to be added to inbound firewall rules. Communication from the admission controller is outbound-initiated only over HTTPS port 443.

## Are regular expressions supported when creating policies? {#are-regular-expressions-supported-when-creating-policies}

We support the keywords "contains" and "start with" for image registry, name, and tag in the first release. This provides a basic regular expressions interface.

## Does each Kubernetes cluster need its own admission controller? {#does-each-kubernetes-cluster-need-its-own-admission-controller}

Yes. Each Kubernetes cluster should have its own admission controller. If you need to, you can scale the desired replicas. The default is 1.

## Will the validation of admission control webhooks cause Container Security to change a container's configuration? {#will-the-validation-of-admission-control-webhooks-cause-container-security-to-change-a-containers-configuration}

No. It only validates if a deployment request is allow or denied in a policy definition.

## During the validating phase, when you run kubectl apply -f \<...\>, does the admission controller query Container Security? If so, is a local cache being used for each query? {#during-the-validating-phase-when-you-run-kubectl-apply--f-...-does-the-admission-controller-query-container-security-if-so-is-a-local-cache-being-used-for-each-query}

Yes. The admission controller queries Container Security everytime a review request happens in Kubernetes, both when doing a `kubectl create` or a `kubectl apply`.

No local cache is being used for queries or policies to ensure the policy is always up to date.

By default, review requests from the kube-system namespace are not forwarded to Container Security. For more information, see the [admission controller yaml file](https://github.com/trendmicro/cloudone-admission-controller-helm/blob/master/values.yaml).

## What is the telemetry in Container Security used for? What kind of data is admission control sending? {#what-is-the-telemetry-in-container-security-used-for-what-kind-of-data-is-admission-control-sending}

For more information about data collection and telemetry, see [Trend Vision One Container Security Data Collection Notice](https://success.trendmicro.com/dcx/s/solution/000295128?language=en_US).

## When should you increase the replica count for the admission controller? {#when-should-you-increase-the-replica-count-for-the-admission-controller}

Consider increasing the replica count for the admission controller in large environments, where many admission requests may occur at the same time. Admission requests occur when a pod scales its replica counts, new deployments occur, etc.

## How do you add pods with multiple containers to exceptions? {#how-do-you-add-pods-with-multiple-containers-to-exceptions}

Pods with multiple containers should have exceptions for all containers inside of them. Container Security only allows the admission request if all requested containers are not violating a policy rule or meet exception criteria.

## Why is my pod not being isolated from network access? {#why-is-my-pod-not-being-isolated-from-network-access}

If you are using the "Isolate" action in your Continuous Compliance policy or Runtime rules, the Kubernetes cluster where the protected resources are running must have Kubernetes network policies enabled. To enable Kubernetes network policies, install a network plugin with NetworkPolicy support using the provided guide in the [Helm chart README](https://github.com/trendmicro/cloudone-container-security-helm).

## Why are vulnerabilities not showing up in the vulnerability view? {#why-are-vulnerabilities-not-showing-up-in-the-vulnerability-view}

This section covers some commonly seen issues in Runtime Scanning, and how to address them.

Scanner pods are getting terminated with an `OOMKilled` status:

- Scanner pod status can be observed through tools such `kubectl`. In this situation, the following log might be observed by running

  ```bash
  kubectl describe nodes:
                       Memory cgroup out of memory: Killed process xxxxx (sbom-job)
  ```

- During normal operations, every unique image deployed in your cluster triggers a scanner pod. This scan job generates a Software Bill of Material (SBOM) for the deployed image, and the SBOM is sent to Trend Vision One for further analysis. If the generated SBOM is larger than the default maximum memory limit of the scan job, then the pod will be terminated with an `OOMKilled` status. Exceptionally large images (such as machine learning images), could lead to exceptionally large SBOMs. To remediate this issue, you can override the [default maximum memory limit of the scan job](https://github.com/trendmicro/cloudone-container-security-helm/blob/master/values.yaml) in your Helm overrides YAML file (usually `overrides.yaml`):

  ```bash
  visionOne:
      bootstrapToken: <BOOTSTRAP_TOKEN>
      endpoint: <ENDPOINT>
      vulnerabilityScanning:
          enabled: true
  resources:
      scanner:
          limits:
              memory: 1024Mi
  ```

- To apply the new configuration, run the helm upgrade command. If you continue encountering the same problem, consider increasing the scanner memory again (for example, `2048Mi`).

Discovered vulnerabilities are disappearing from the vulnerability view:

- The runtime scanning vulnerability view is currently a live representation of vulnerabilities in your cluster. Once a vulnerability is no longer running in the cluster (the vulnerable container is terminated), it will be immediately removed from the vulnerability view.

## Can I have multiple scan tools installed in my cluster? {#can-i-have-multiple-scan-tools-installed-in-my-cluster}

It is recommended to only include one scanning tool in each cluster, as multiple such tools running concurrently can cause unpredictable behavior where both tools continuously scan each other's pods. If this situation is not avoidable, you can exclude the other scan tool's namespace from Container Security scans by adding the following to your overrides file:

```bash
visionOne:
exclusion:
namespaces: [list, of, namespaces]
```

It is also recommended to exclude the namespace where you installed Container Security from getting scanned by the other scan tool.

## When should I increase the maximum concurrency for the vulnerability scanner pods? {#when-should-i-increase-the-maximum-concurrency-for-the-vulnerability-scanner-pods}

Large clusters could benefit from increasing the [default maximum concurrency for the vulnerability scanner pods](https://github.com/trendmicro/cloudone-container-security-helm/blob/master/values.yaml) to drive faster scan results, by using more of your cluster's resources. The scanner pod concurrency limit is meant to constrain Container Security's resource usage within your cluster. For example, if the concurrency limit was set to 5, then a maximum of 5 unique images can be scanned at a time. Modifying the scanner pod concurrency limit can be done through your overrides file:

```bash
visionOne:
scanManager:
maxJobCount: 15
```

When increasing the concurrency limit for the vulnerability scanner pods, please ensure your cluster has enough resources to handle the additional scanner pods. You can change the default resource requirements for each scanner pod by changing the `maxJobCount` value in the `scanManager` section of the [Helm chart](https://github.com/trendmicro/cloudone-container-security-helm/blob/master/values.yaml).

## How do I collect ECS Scout service logs? {#how-do-i-collect-ecs-scout-service-logs}

To efficiently collect logs from the ECS Scout service, follow the steps below:

### Procedure {#procedure-1}

1.  Access the service by navigating to your ECS cluster and select the **trendmicro-scout** service.

2.  Click the **Logs** tab.

3.  Apply container and time filters to refine your search and focus on the most recent logs relevant to your analysis.

4.  To further analyze the logs, click **View in CloudWatch**. In CloudWatch, you have the option to download the logs in CSV format for detailed examination and archival purposes.

## How do I pull images from a private registry? {#how-do-i-pull-images-from-a-private-registry}

By default, Container Security stores public container images in the [Amazon ECR Public Gallery](https://gallery.ecr.aws/trendmicro?page=1) and pulls those images into clusters as defined by the [helm chart](https://github.com/trendmicro/cloudone-container-security-helm/blob/master/values.yaml). Using a private registry allows image pulls that are not rate-limited, and allows container images to be stored in a way that aligns with company best practices.

To pull images from a private registry, use the steps below:

:::note

The steps below use a private Amazon Elastic Container Registry (ECR) as an example, but the process will vary depending on which container registry you use.
:::

### Procedure {#procedure-2}

1.  Follow the Amazon User Guide instructions (steps 1 to 8) [to create a pull through cache rule (AWS Management Console) for Amazon ECR Public](https://docs.aws.amazon.com/AmazonECR/latest/userguide/pull-through-cache-creating-rule.mdx).

2.  Modify the helm overrides file to use your private ECR registry URL, project name, and image pull secret using the following format:

    ```bash
    images:
      defaults:
        registry: <your-private-registry>
        project: <prefix-path>
        imagePullSecret: <pull-secret-if-needed>
    ```

    For example:

    ```bash
    images:
      defaults:
        registry: <aws-account>.dkr.ecr.us-east-1.amazonaws.com
        project: <namespace>/trendmicro/container-security
        imagePullSecret: <ecr-cred>
    ```

    :::tip

    You can use the `helm install` or `helm upgrade` command to modify your helm overrides file values.
    :::

## Why does the sidecar container exit with code 137 in AWS Fargate? {#why-does-the-sidecar-container-exit-with-code-137-in-aws-fargate}

In AWS Fargate, when the essential container of a task stops normally (either finishes its process or exits cleanly), AWS automatically initiates the task shutdown by stopping all other containers in the task, including the sidecars. If a sidecar container, like `trendmicro-scout` for example, does not exit within a short timeout window during this shutdown process, AWS sends a `SIGKILL` (signal 9) message to forcibly terminate the container, resulting in exit code 137. This is expected behavior and does not indicate an error or abnormal termination of the sidecar container.

## How do I resolve a Trend Vision One Container Security Argo CD application stuck in a Deleting state during uninstall? {#how-do-i-resolve-a-trend-vision-one-container-security-argo-cd-application-stuck-in-a-deleting-state-during-uninstall}

You can use the [argocd-cleanup.sh](https://github.com/trendmicro/visionone-container-security-helm/blob/main/scripts/argocd-cleanup.sh) script to resolve a Trend Vision One Container Security Argo CD application stuck in a Deleting state during the uninstall process. This script helps delete finalizers and resources preventing the complete removal of the application. For more information, see [Argo CD cleanup script for Container Security](https://github.com/trendmicro/visionone-container-security-helm/blob/main/scripts/argocd-cleanup.mdx).

## How do I verify the authenticity of Trend Micro container images with Cosign public keys? {#how-do-i-verify-the-authenticity-of-trend-micro-container-images-with-cosign-public-keys}

Cosign is a trusted tool for container signing and verification that you can use to authenticate Trend Micro container images. This verification process ensures that your container images were legitimately published by Trend Micro.

:::note

These steps are specifically meant to verify Trend Micro container images. If you want to verify your own container images using trusted public keys, see [Managing attestors](managing-attestors.mdx).
:::

1.  Install Cosign using Homebrew (macOS/Linux):

    ```bash
    brew install cosign
    ```

    For other installation methods, refer to the [Cosign documentation](https://docs.sigstore.dev/cosign/signing/signing_with_containers/).

2.  Save your Trend Micro public key to a file named `cosign.pub`. For example:

    ```bash
    -----BEGIN PUBLIC KEY-----
    MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE6N2uJjDtSNmTrfg/+GEU8ZzuKxAH
    yXSc+SQdFeBb+eDpme+rNYVwf8ZuX6ii+4RhGW8IVHnyx458B2nlNrndqQ==
    -----END PUBLIC KEY-----
    ```

3.  Verify the container image using the saved public key:

    ```bash
    cosign verify --key cosign.pub public.ecr.aws/trendmicro/container-security/<image-name>:<tag> --insecure-ignore-tlog
    ```

    :::note

    Replace `<image-name>` and `<tag>` with the specific Trend Micro container image name and version you want to verify. The available image names and tags can be found in the [Amazon ECR Public Gallery](https://gallery.ecr.aws/trendmicro?page=1).
    :::

4.  View the cosign verification results:

    - If verification succeeds, you'll see confirmation that the signature is valid.

    - If verification fails, do not use the image. Contact Trend Micro support.
:::::
